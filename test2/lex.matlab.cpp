// lex.matlab.cpp generated by reflex 3.3.7 from matlab.l

#define REFLEX_VERSION "3.3.7"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_flex
#undef REFLEX_OPTION_header_file
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_prefix
#undef REFLEX_OPTION_yyclass

#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_header_file         "matlab_lexer.h"
#define REFLEX_OPTION_lex                 matlablex
#define REFLEX_OPTION_lexer               matlabFlexLexer
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "lex.matlab.cpp"
#define REFLEX_OPTION_prefix              matlab
#define REFLEX_OPTION_yyclass             MatlabLexer

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 7 "matlab.l"

    #include "matlab.tab.h"  // Generated by bison
    #include <string>


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define COMMENT (1)
#define STRING (2)
#define YY_NUM_RULES (34)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS INCLUDE                                                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "matlab_lexer.h"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int MatlabLexer::matlablex(void)
{
  static const char *REGEX_INITIAL = "(?m)((?:\\Q%\\E))|((?:\\Q'\\E))|((?:\\Q[\\E))|((?:\\Q]\\E))|((?:\\Q(\\E))|((?:\\Q)\\E))|((?:\\Q{\\E))|((?:\\Q}\\E))|((?:\\Q=\\E))|((?:\\Q,\\E))|((?:\\Q;\\E))|((?:\\Q:\\E))|((?:\\Q...\\E))|((?:\\Qif\\E))|((?:\\Qelse\\E))|((?:\\Qelseif\\E))|((?:\\Qend\\E))|((?:\\Qfor\\E))|((?:\\Qwhile\\E))|((?:\\Qfunction\\E))|((?:\\Qreturn\\E))|((?:\\Qbreak\\E))|((?:\\Qcontinue\\E))|((?:(?:[0-9])+))|((?:(?:[0-9])+(?:\\Q.\\E)(?:[0-9])*))|((?:[A-Z_a-z][0-9A-Z_a-z]*))|([\\x09\\x0d\\x20]+)|(\\n)|(.)";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_COMMENT = "(?m)(\\n)|(.)";
  static const reflex::Pattern PATTERN_COMMENT(REGEX_COMMENT);
  static const char *REGEX_STRING = "(?m)((?:\\Q'\\E))|([^']+)|(\\\\.)";
  static const reflex::Pattern PATTERN_STRING(REGEX_STRING);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  switch (start())
  {
    case INITIAL:
#line 35 "matlab.l"

    // Code to execute for each rule
    #define TOKEN(t) return matlab::parser::token::t

    break;
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule matlab.l:36: "%" :
            YY_USER_ACTION
#line 36 "matlab.l"
{ BEGIN(COMMENT); }
            YY_BREAK
          case 2: // rule matlab.l:40: "'" :
            YY_USER_ACTION
#line 40 "matlab.l"
{ BEGIN(STRING); string_buf.clear(); }
            YY_BREAK
          case 3: // rule matlab.l:45: "[" :
            YY_USER_ACTION
#line 45 "matlab.l"
{ TOKEN(LBRACKET); }
            YY_BREAK
          case 4: // rule matlab.l:46: "]" :
            YY_USER_ACTION
#line 46 "matlab.l"
{ TOKEN(RBRACKET); }
            YY_BREAK
          case 5: // rule matlab.l:47: "(" :
            YY_USER_ACTION
#line 47 "matlab.l"
{ TOKEN(LPAREN); }
            YY_BREAK
          case 6: // rule matlab.l:48: ")" :
            YY_USER_ACTION
#line 48 "matlab.l"
{ TOKEN(RPAREN); }
            YY_BREAK
          case 7: // rule matlab.l:49: "{" :
            YY_USER_ACTION
#line 49 "matlab.l"
{ TOKEN(LBRACE); }
            YY_BREAK
          case 8: // rule matlab.l:50: "}" :
            YY_USER_ACTION
#line 50 "matlab.l"
{ TOKEN(RBRACE); }
            YY_BREAK
          case 9: // rule matlab.l:51: "=" :
            YY_USER_ACTION
#line 51 "matlab.l"
{ TOKEN(EQUALS); }
            YY_BREAK
          case 10: // rule matlab.l:52: "," :
            YY_USER_ACTION
#line 52 "matlab.l"
{ TOKEN(COMMA); }
            YY_BREAK
          case 11: // rule matlab.l:53: ";" :
            YY_USER_ACTION
#line 53 "matlab.l"
{ TOKEN(SEMICOLON); }
            YY_BREAK
          case 12: // rule matlab.l:54: ":" :
            YY_USER_ACTION
#line 54 "matlab.l"
{ TOKEN(COLON); }
            YY_BREAK
          case 13: // rule matlab.l:55: "..." :
            YY_USER_ACTION
#line 55 "matlab.l"
{ TOKEN(ELLIPSIS); }

            YY_BREAK
          case 14: // rule matlab.l:57: "if" :
            YY_USER_ACTION
#line 57 "matlab.l"
{ TOKEN(IF); }
            YY_BREAK
          case 15: // rule matlab.l:58: "else" :
            YY_USER_ACTION
#line 58 "matlab.l"
{ TOKEN(ELSE); }
            YY_BREAK
          case 16: // rule matlab.l:59: "elseif" :
            YY_USER_ACTION
#line 59 "matlab.l"
{ TOKEN(ELSEIF); }
            YY_BREAK
          case 17: // rule matlab.l:60: "end" :
            YY_USER_ACTION
#line 60 "matlab.l"
{ TOKEN(END); }
            YY_BREAK
          case 18: // rule matlab.l:61: "for" :
            YY_USER_ACTION
#line 61 "matlab.l"
{ TOKEN(FOR); }
            YY_BREAK
          case 19: // rule matlab.l:62: "while" :
            YY_USER_ACTION
#line 62 "matlab.l"
{ TOKEN(WHILE); }
            YY_BREAK
          case 20: // rule matlab.l:63: "function" :
            YY_USER_ACTION
#line 63 "matlab.l"
{ TOKEN(FUNCTION); }
            YY_BREAK
          case 21: // rule matlab.l:64: "return" :
            YY_USER_ACTION
#line 64 "matlab.l"
{ TOKEN(RETURN); }
            YY_BREAK
          case 22: // rule matlab.l:65: "break" :
            YY_USER_ACTION
#line 65 "matlab.l"
{ TOKEN(BREAK); }
            YY_BREAK
          case 23: // rule matlab.l:66: "continue" :
            YY_USER_ACTION
#line 66 "matlab.l"
{ TOKEN(CONTINUE); }

            YY_BREAK
          case 24: // rule matlab.l:68: {INT} :
            YY_USER_ACTION
#line 68 "matlab.l"
{ yylval->ival = atoi(yytext); TOKEN(INTEGER); }
            YY_BREAK
          case 25: // rule matlab.l:69: {FLOAT} :
            YY_USER_ACTION
#line 69 "matlab.l"
{ yylval->dval = atof(yytext); TOKEN(FLOAT); }
            YY_BREAK
          case 26: // rule matlab.l:70: {ID} :
            YY_USER_ACTION
#line 70 "matlab.l"
{ yylval->str = new std::string(yytext); TOKEN(IDENTIFIER); }

            YY_BREAK
          case 27: // rule matlab.l:72: [ \t\r]+ :
            YY_USER_ACTION
#line 72 "matlab.l"
{ /* ignore whitespace */ }
            YY_BREAK
          case 28: // rule matlab.l:73: \n :
            YY_USER_ACTION
#line 73 "matlab.l"
{ /* ignore newline or count lines */ }

            YY_BREAK
          case 29: // rule matlab.l:75: . :
            YY_USER_ACTION
#line 75 "matlab.l"
{ /* handle error */ }

            YY_BREAK
        }
        break;
      case COMMENT:
        matcher().pattern(PATTERN_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule matlab.l:37: \n :
            YY_USER_ACTION
#line 37 "matlab.l"
{ BEGIN(INITIAL); }
            YY_BREAK
          case 2: // rule matlab.l:38: . :
            YY_USER_ACTION
#line 38 "matlab.l"
{ /* ignore comment content */ }

            YY_BREAK
        }
        break;
      case STRING:
        matcher().pattern(PATTERN_STRING);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule matlab.l:41: "'" :
            YY_USER_ACTION
#line 41 "matlab.l"
{ BEGIN(INITIAL); yylval->str = new std::string(string_buf); TOKEN(STRING_LITERAL); }
            YY_BREAK
          case 2: // rule matlab.l:42: [^']+ :
            YY_USER_ACTION
#line 42 "matlab.l"
{ string_buf += yytext; }
            YY_BREAK
          case 3: // rule matlab.l:43: \\. :
            YY_USER_ACTION
#line 43 "matlab.l"
{ string_buf += yytext[1]; }  // Handle escape sequences

            YY_BREAK
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 78 "matlab.l"

// Additional C++ code can go here
